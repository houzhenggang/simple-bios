#================================================
#=================== SCANBIOS ===================

.equ	BEGSEG, 	0xC000						# Сегмент, с которого начнём искать
.equ	ENDSEG,		0xF000						# Сегмент, на котором поиск закончится

#------------------[ scanbios ]-----------------#
scanbios: 										#
		mov		$BEGSEG, %dx					# 
cycle:	mov		%dx, %ds						# 
		call    scanmodules						#
		cmp		$ENDSEG, %dx					# mov dx, cs:ENDSEG
		jb		cycle							#
		PutString  "\r\n", 0					# Printing empty strings
		PutString  "\r\n", 0					#
		ret										#
#-----------------------------------------------#

#----------------[ scanmodules ]----------------# scanmodules принимает в dx текущее смещение
scanmodules: 									# ... и возвращает в dx новое смещение (в котором будет проверять память
		cld										# ... на наличие модуля в следующий раз)
		cmpw	$0xAA55, %ds:0					# проверяем контрольное слово (0xAA55).
		jne		next							# if word ptr DS:[0] != 0AA55h
												# goto next
												
#--------[ Проверка контрольной суммы ]---------# Этот участок - проверка контрольной суммы. Сумма всех байт модуля должна быть равна 0 по модулю 256.					
		xor		%si, %si						# Т.е. sum % 256 = 0. 
		xor		%cx, %cx						#
		mov		%ds:2, %ch						# Загружаем в ch размер сегмента. (ds+2)
		xor		%bl, %bl						#
		
chcksm: lodsw									# 
		add		%ah, %al						# Тут это реализовано следующим образом - берется половина регистра bx (bl). Её размер - 1 байт.
		add		%al, %bl 						# Поэтому, если прибавлять к bl все байты, содержащиеся в модуле, то  в итоге должен получиться 0, если контрольная сумма верная.
		dec		%cx								# Если сумма верная - выполняем модуль, если неверная - пропускаем его.
		jnz		chcksm							#
												#
		or		%bl, %bl						#
		jnz		round							#
#-----------------------------------------------#

#--------------[ запуск модуля... ]-------------#
		pusha									#
		push    %ds								#
		push    %es								#
		push    %fs								#	
		push    %gs								#  Не вникайте, почему модули запускаются таким извращенным образом
												#  Просто не трогайте этот участок кода. Он взят из x64.pdf
		push    %cs								#
		push    $init_done						#
		push    %ds								#
		push    $3								#
		retf									#
init_done:										#
		pop		%gs								#
		pop		%fs								#
		pop		%es								#
		pop		%ds								#
		popa									#
#-----------------------------------------------# запустили модуль

#----------[ Округляем адрес сегмента ]---------# Тут мы округляем адрес следующего сегмента так, чтобы он был кратен 2048 байтам.
round:											# Попробуйте вникнуть, делая все эти операции на бумажке. Это нужно делать, например,
		xor		%eax, 	%eax					# если мы выполнили модуль размером 3*512 байт. Тогда, если просто добавить размер модуля,
		mov		%ds:2, 	%al						# в следующий раз мы начнем не с (текущий адрес + 2048 байт), а с (текущий адрес + 1536 байт)
		shl		$5,		%ax 					# Но это будет ошибкой, так как все модули располагаются по сетке в 2048 байт!
		add		%eax, 	%edx					# Т.е. нужно округлить адрес до ближайшего числа, кратного 2048. 
												# Или, иначе говоря, округлить сегмент до ближайшего числа, кратного 80h (2048/16 = 128 = 80h)
		cmp		$ENDSEG, %edx					# Таким образом, в сегменте в итоге должно оказаться число 0x80, 0x100, 0x180, 0x200 и т.д.
		jge		over							#                                                          (128, 256,   384,   512 и т.д.)
		
		add		$0x7F,	 %dx					#	0000 0000 0111 1111	# %dx до округления имеет значения	  1*** **** *000 0000
		and		$0xFF80, %dx					#	1111 1111 1000 0000	# после прибавления размера сегмента: 1*** **** *sss 0000
		ret										#	прибавим к нему (80h - 1) и затем отбросим биты, какие 
												#	нас не интересуют, т.е. первые 7 (с конца, потому что тут LE) c помощью лог. и
#-----------------------------------------------#  округлили

next:				
		add		$0x80, 	%dx						# + 2048 bytes
		ret		
over:
		mov		$ENDSEG, %dx
		ret		
#-----------------------------------------------# коонец scanmodules
#================================================

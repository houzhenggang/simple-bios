;================================================
;=================== SCANBIOS ===================

BEGSEG  equ		0C000h							; Сегмент, с которого начнём искать
ENDSEG  equ		0F000h							; Сегмент, на котором поиск закончится

;------------------[ scanbios ]-----------------;
scanbios proc near								;
		mov		dx, BEGSEG						; 
cycle:	mov		ds, dx							; 
		call    scanmodules						;
		cmp		dx, ENDSEG						; mov dx, cs:ENDSEG
		jb		cycle							;
		ret										;
scanbios endp									;
;-----------------------------------------------;

;----------------[ scanmodules ]----------------; scanmodules принимает в dx текущее смещение
scanmodules proc near							; ... и возвращает в dx новое смещение (в котором будет проверять память
		cld										; ... на наличие модуля в следующий раз)
		cmp		word ptr DS:[0], 0AA55h			; проверяем контрольное слово (0xAA55).
		jne		next							; if word ptr DS:[0] != 0AA55h
												; goto next
												;
;--------[ Проверка контрольной суммы ]---------; Этот участок - проверка контрольной суммы. Сумма всех байт модуля должна быть равна 0 по модулю 256.					
		xor		si, si							; Т.е. sum % 256 = 0. 
		xor		cx, cx							;
		mov		ch, DS:[2]						; Загружаем в ch размер сегмента. (ds+2)
		xor		bl, bl							;
		
chcksm: lodsw									; 
		add		al, ah							; Тут это реализовано следующим образом - берется половина регистра bx (bl). Её размер - 1 байт.
		add		bl, al							; Поэтому, если прибавлять к bl все байты, содержащиеся в модуле, то  в итоге должен получиться 0, если контрольная сумма верная.
		dec		cx								; Если сумма верная - выполняем модуль, если неверная - пропускаем его.
		jnz		short chcksm					;
												;
		or		bl, bl							;
		jnz		round							;
;-----------------------------------------------;

;--------------[ запуск модуля... ]-------------;
		pusha									;
		push    ds								;
		push    es								;
		push    fs								;	
		push    gs								;  Не вникайте, почему модули запускаются таким извращенным образом
												;  Просто не трогайте этот участок кода. Он взят из x64.pdf
		push    CS								;
		push    offset __ret					;
		push    DS								;
		push    3h								;
		retf									;
__ret:											;
		pop		gs								;
		pop		fs								;
		pop		es								;
		pop		ds								;
		popa									;
;-----------------------------------------------; запустили модуль


;----------[ Округляем адрес сегмента ]---------; Тут мы округляем адрес следующего сегмента так, чтобы он был кратен 2048 байтам.
round:											; Попробуйте вникнуть, делая все эти операции на бумажке. Это нужно делать, например,
		xor		eax, eax						; если мы выполнили модуль размером 3*512 байт. Тогда, если просто добавить размер модуля,
		mov		al,	ds:2						; в следующий раз мы начнем не с (текущий адрес + 2048 байт), а с (текущий адрес + 1536 байт)
		shl		ax, 5							; Но это будет ошибкой, так как все модули располагаются по сетке в 2048 байт!
		add		edx, eax						; Т.е. нужно округлить адрес до ближайшего числа, кратного 2048. 
												; Или, иначе говоря, округлить сегмент до ближайшего числа, кратного 80h (2048/16 = 128 = 80h)
		cmp		edx, ENDSEG						; Таким образом, в сегменте в итоге должно оказаться число 0x80, 0x100, 0x180, 0x200 и т.д.
		jge		over							;                                                          (128, 256,   384,   512 и т.д.)
		
		add		dx, 7Fh							;	0000 0000 0111 1111	; dx до округления имеет значения	  1*** **** *000 0000
		and		dx, 0FF80h						;	1111 1111 1000 0000	; после прибавления размера сегмента: 1*** **** *sss 0000
		ret		0								;	прибавим к нему (80h - 1) и затем отбросим биты, какие 
												;	нас не интересуют, т.е. первые 7 (с конца, потому что тут LE) c помощью лог. и
;-----------------------------------------------;  округлили

next:				
		add		dx, 80h							; + 2048 bytes
		ret		0
over:
		mov		dx, ENDSEG
		ret		0
scanmodules endp								;
;-----------------------------------------------; коонец scanmodules

;================================================
